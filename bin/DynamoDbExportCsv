#!/usr/bin/env node
'use strict';

var dynamoDbExport = require('../lib/DynamoDbExportCsv.js');
var commander = require('commander');
var fs = require('fs');

commander.version('0.0.1')
    .option('-i, --awsid [awsid]', 'AWS Secret ID')
    .option('-s, --awssecret [awssecret]', 'AWS Secret Access Key')
    .option('-r, --awsregion <awsregion>', 'AWS Region')
    .option('-t, --table <tableName>', 'Table to export')
    .option('-c, --columns <columns>', 'CSV list of columns')
    .option('--filter-expression <filterExpression>', 'FilterExpression')
    .option('--expression-attribute-values <expressionAttributeValues>', 'ExpressionAttributeValues')
    .option('--expression-attribute-names <expressionAttributeNames>', 'ExpressionAttributeNames')
    .option('-b, --bucket [s3bucket]', 'Optional S3 Bucket to upload to')
    .option('-p, --path [s3path]', 'Optional s3 path')
    .option('-g, --gzip', 'Gzip output')
    .option('-f, --filesize [filesize]', 'Size of each file in Mb.  If ommitted 250Mb', parseInt)
    .option('-s, --scans [parallelscans]', 'Parallel scans to run - Defaults to 1', parseInt)
    .option('-w, --worker [scanindex]', 'Which portion of a parallel scan this worker will do - If specified will only scan this portion of table', parseInt)
    .option('-q, --quiet', 'Turn off progress information')
    .parse(process.argv);

if (! commander.table)
{
    console.error("You must specify a table");
    commander.outputHelp();
    process.exit(1);
}

if(! commander.awsregion)
{
    console.error("You must specify an aws region");
    commander.outputHelp();
    process.exit(1);
}


if (! commander.columns)
{
    console.error("You must specify a list of columns");
    commander.outputHelp();
    process.exit(1);
}

if (commander.filterExpression)
{
    if (commander.expressionAttributeValues)
    {
        try {
            commander.expressionAttributeValues = loadFileOrJsonString(commander.expressionAttributeValues);
        } catch (e) {
            console.error("Providerd ExpressionAtributeValues is neither valid path or JSON");
            console.error(e);
            process.exit(1);
        }
        console.debug("Passed ExpressionAtributeValues");
    }
    if (commander.expressionAttributeNames)
    {
        try {
            commander.expressionAttributeNames = loadFileOrJsonString(commander.expressionAttributeNames);
        } catch (e) {
            console.error("Providerd ExpressionAtributeNames is neither valid path or JSON");
            console.error(e);
            process.exit(1);
        }
        console.debug("Passed ExpressionAtributeNames");
    }
}

var parallelScans = 1;
if (commander.scans)
{
    parallelScans = commander.scans;
}

var columns = commander.columns.split(',');

if(commander.worker!==undefined) {
    console.info("Export DynamoDb table: " + commander.table + ", scan index: " + commander.worker);
}
else {
    console.info("Export DynamoDb table: " + commander.table + ", parallel scans: " + parallelScans);
}

var exporter = new dynamoDbExport(commander.awsid, commander.awssecret, commander.awsregion);

if(!commander.quiet) {
exporter.on("info", function(message) {
    console.info(message);
});

exporter.on("error", function(message) {
    console.error(message);
});

exporter.on("throughputexceeded", function() {
    console.warn("Throughput exceeded");
});
}

var finished = function(err) {
    var workerPrefix = "";
    if(commander.worker!==undefined) {
        workerPrefix = "Worker [" + commander.worker + "]: ";
    }

    if(err) {
        console.error(workerPrefix + "Finished with errors: ", err);
        process.exit(1);
    }
    else {
        console.info(workerPrefix + "Done exporting table");
        process.exit(0);
    }

};

if(commander.worker!==undefined) {
    exporter.exportTableWorker(commander.table, columns, parallelScans, commander.worker, commander.gzip, commander.filesize, commander.bucket, commander.path, commander.filterExpression, commander.expressionAttributeValues, commander.expressionAttributeNames, finished);
}
else {
    exporter.exportTable(commander.table, columns.join(','), parallelScans, commander.gzip, commander.filesize, commander.bucket, commander.path, commander.filterExpression, commander.expressionAttributeValues, commander.expressionAttributeNames, finished);
}

function IsJsonString(str) {
    try {
        JSON.parse(str);
    } catch (e) {
        return false;
    }
    return true;
}

function loadFileOrJsonString(input) {
    var text = "";
    if (IsJsonString(input)) text = input;
    else text = fs.readFileSync(input, "utf8");

    return JSON.stringify(JSON.parse(text));
}